//this function does what its name says
template <class T>
int LinkedList<T>::GetNumberOfObjects()
{
    Node<T> * item = myFirst;
    int i=0;
    
    if (item->GetThingPointer() == 0) return 0;
    while (item != 0)
    {
        item = item->GetNext();
        ++i;
    }
    return i;
}

//here a pointer to the object is returned
template <class T>
T * LinkedList<T>::GetThing (int objectIndex)
{
    Node<T> * item = myFirst;
    
    int i = 0;
    while (i < objectIndex)
    {
        item = item->GetNext();
        ++i;
    }
    return item->GetThingPointer();
}

//the function does the real checking work:
//it starts at a blob-pixel and checks if its four neighbours are blob-pixels, too.
//if so, it inserts them in the pixel-list and returns true for telling:
//I have found another pixel
bool Pixel::CheckAllNeighbours (LinkedList<Pixel> & pixelList)
{
    bool haveFoundOtherBlobPixels = false;
    
    // Set pixel in image to 0, so that it will not be found twice, store value before
    mybc->spectrum[myPosition] =  0;
    
    //Check above
    if (myPosition < mybc->width) ;
    else
    {
        haveFoundOtherBlobPixels |= CheckNeighbour(pixelList, myPosition - mybc->width );
    }
    
    //Check below
    if (myPosition >= (mybc->height-1) * mybc->width) ;
    else
    {
        haveFoundOtherBlobPixels |= CheckNeighbour(pixelList, myPosition + mybc->width );
    }
    
    //Check left
    if ((myPosition % mybc->width)== 0) ;
    else
    {
        haveFoundOtherBlobPixels |= CheckNeighbour(pixelList, myPosition - 1);
    }
    
    //Check right
    if ( (myPosition % mybc->width) == (mybc->width -1)) ;
    else
    {
        haveFoundOtherBlobPixels |= CheckNeighbour(pixelList, myPosition + 1);
    }
    
    myNeighboursChecked = true;
    return haveFoundOtherBlobPixels;
}

//just a help function, for not writing the same code for every check
bool Pixel::CheckNeighbour (LinkedList<Pixel> & pixelList, int anotherPosition)
{
    if (mybc->spectrum[anotherPosition] > mybc->threshold )
    {
        Pixel * anotherBlobPixel = new Pixel(anotherPosition, mybc);
        pixelList.Insert(anotherBlobPixel);
        mybc->spectrum[anotherPosition] =  0;
        return true;
    }
    else return false;
}


//Function for restoring image as pixels in a blob are set to zero
void Blob::RecreateArea()
{
    Pixel * pixelPointer;
    
    if (!myAreaFound) FindArea();
    for (int i = 0; i < myArea; ++i)
    {
        pixelPointer = myPixelList.GetThing(i);
        pixelPointer->ResetZValue();
    }
}

//function that takes the pixellist generated by FindArea() and computes the center of mass
Position * Blob::GetPosition()
{
    float x = 0, y = 0, integratedArea = 0;
    Pixel * pixelPointer;
    int pixelPosition;
    float z;
    
    if (!myAreaFound) FindArea();
    for (int i = 0; i < myArea; ++i)
    {
        pixelPointer = myPixelList.GetThing(i);
        pixelPosition = pixelPointer->GetPosition();
        z = pixelPointer->GetZValue();
        integratedArea += z;
        x += (pixelPosition % mybc->width) * z;
        y += (static_cast<int>(pixelPosition / mybc->width )) * z;
    }
    myPosition->SetXPosition(x / integratedArea);
    myPosition->SetYPosition(y / integratedArea);
    myPosition->SetIntegral(integratedArea);
    myPosition->SetArea(myArea);
    return myPosition;
}

//function that does a lot of work in BlobFinding:
//scans the pixellist and checks, if every pixel has checked its neighbourhood
//if not, it makes the pixel check its neighbourhood and restarts with scanning the pixellist
//(if there are new pixels inserted)
int Blob::FindArea()
{
    while (!myAreaFound)
    {
        Pixel * pixelPointer;
        
        myAreaFound = true;
        myArea = myPixelList.GetNumberOfObjects();
        for (int i = 0; i < myArea; ++i)
        {
            pixelPointer = myPixelList.GetThing(i);
            if (!pixelPointer->GetNeighboursChecked())
            {
                if ( pixelPointer->CheckAllNeighbours(myPixelList) ) //CheckAllNeighbours is true, if other blob-pixels are found
                {
                    myAreaFound = false;
                    break;
                }
            }
        }
    }
    myArea = myPixelList.GetNumberOfObjects();
    return myArea;
}

//Just returns the number of pixels in a blob
int Blob::GetArea()
{
    if (!myAreaFound) FindArea();
    return myArea;
}


//this main function just passes the tasks around:
//it starts scanning the image until two neighbouring pixels above threshold are found
//(so clustersize should be >=2, to be honest)
//it creates a blob and makes the blob grow by itself recursively.
//After having checked the whole image and created a full blob-list,
//it is checked, if the blobs are big enough and their positions are
//inserted in the main output of the algorithm: the position-list
//
//Attention:
//you should decide for yourself, if you use the RecreateArea function
//because during BlobFinding the pixels in a blob are set to zero.
//As this is done directly in the pointer to the data, you should recreate the Area
//if you want to process the data more in the same run of "loop images"
//Since data is stored in a file that is not changed, you can leave it out
//to improve speed
int BlobFindingMain::GetBlobPositions(LinkedList<Position> * myBlobCenterList, bool recreateArea)
{
    //here starts variable definition for BlobFinding
    int firstHalfBeginning = 0,
    firstHalfEnd = (static_cast<int> (mybc->height / 2)) * mybc->width -1,
    bufferBeginning = firstHalfEnd + 1,
    bufferEnd = firstHalfEnd + mybc->width,
    secondHalfBeginning = bufferEnd + 1,
    secondHalfEnd = mybc->width * mybc->height,
    ret;
    int * nrOfBufferBlobs;
    int * nrOfBlobsOne;
    int * nrOfBlobsTwo;
    LinkedList<Position> *  list_one = new LinkedList<Position>;
    LinkedList<Position> *  list_two = new LinkedList<Position>;
   	
    nrOfBufferBlobs = GetBlobPositionsPart (myBlobCenterList, bufferBeginning, bufferEnd, recreateArea);
    nrOfBlobsOne = GetBlobPositionsPart (list_one, firstHalfBeginning, firstHalfEnd, recreateArea);
    nrOfBlobsTwo = GetBlobPositionsPart (list_two, secondHalfBeginning, secondHalfEnd, recreateArea);
    
    for (int i = 0; i < *nrOfBlobsOne; ++i)
    {
        Position * pos = new Position ( list_one->GetThing(i) );
        myBlobCenterList->Insert( pos );
    }
    for (int j = 0; j < *nrOfBlobsTwo; ++j)
    {
        Position * pos = new Position ( list_two->GetThing(j) );
        myBlobCenterList->Insert( pos );
    }
    
    delete list_one;  list_one = 0;
    delete list_two;  list_two = 0;
    ret = *nrOfBufferBlobs + *nrOfBlobsOne + *nrOfBlobsTwo;
    delete nrOfBufferBlobs;  nrOfBufferBlobs = 0;
    delete nrOfBlobsOne;  nrOfBlobsOne = 0;
    delete nrOfBlobsTwo;  nrOfBlobsTwo = 0;
    
    return ret;
}

int * BlobFindingMain::GetBlobPositionsPart(LinkedList<Position> * myBlobCenterList, int startPixel, int endPixel, bool recreateArea)
{
    LinkedList<Blob> * myBlobList = new LinkedList<Blob>;
    int lastPixel = mybc->size;
    int * nrOfBigBlobs = new int(0);
    
    if (endPixel > lastPixel) endPixel = lastPixel;
    
    while ( startPixel < endPixel )
    {
        for (int i = startPixel+1 ; i < (startPixel + mybc->width - 1) ; ++i )
        {
            if (mybc->spectrum[i] > mybc->threshold )
            {
                    Blob * blobPointer = new Blob(i, mybc);
                    blobPointer->FindArea();
                    myBlobList->Insert(blobPointer);
            }
        }
        startPixel += (2*mybc->width);
    }
    int nrOfBlobs = myBlobList->GetNumberOfObjects();
    for (int j = 0; j < nrOfBlobs; ++j)
    {
        Blob * blobPointer = myBlobList->GetThing(j);
        if (blobPointer->GetArea() >= mybc->clustersize )
        {
            ++(*nrOfBigBlobs);
            Position * pos = new Position( blobPointer->GetPosition() );
            myBlobCenterList->Insert( pos );
        }
        if (recreateArea) blobPointer->RecreateArea();
    }
    
    delete myBlobList;
    myBlobList = 0;
    
    return nrOfBigBlobs;
}

